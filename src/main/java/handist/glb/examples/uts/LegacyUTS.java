/*******************************************************************************
 * This file is part of the Handy Tools for Distributed Computing project
 * HanDist (https:/github.com/handist)
 *
 * This file is licensed to You under the Eclipse Public License (EPL);
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 	https://www.opensource.org/licenses/eclipse-1.0.php
 *
 * (C) copyright CS29 Fine 2018-2021
 ******************************************************************************/
package handist.glb.examples.uts;

import java.io.Serializable;
import java.security.DigestException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import handist.glb.legacy.Bag;
import handist.glb.legacy.GLBProcessor;
import handist.glb.legacy.GLBProcessorFactory;
import handist.glb.legacy.Logger;
import handist.glb.util.HypercubeStrategy;

/**
 * Implementation of an Unbalanced Tree Search computation.
 * <p>
 * This class is an adaptation from the <a href=
 * "https://github.com/x10-lang/apgas/blob/master/apgas.examples/src/apgas/examples/UTS.java">apgas.examples.UTS</a>
 * class to fit the {@link handist.glb.legacy.Bag} interface of the "legacy"
 * load balancer. The result returned by {@link LegacyUTS} is the number of
 * nodes explored, using the {@link Sum} class.
 *
 * @author Patrick Finnerty
 *
 */
public class LegacyUTS implements Serializable, Bag<LegacyUTS, Sum> {

    /** Serial Version UID */
    private static final long serialVersionUID = 2200935927036145803L;

    /** Branching factor: 4 */
    private static final double den = Math.log(4.0 / (1.0 + 4.0));

    /** Array containing the seed for each node's subtree */
    byte[] hash;

    /** Keeps track of the tree level corresponding to the index */
    int[] depth;

    /**
     * Lower bound of the number of nodes left to explore at this level of this
     * search
     */
    int[] lower;

    /**
     * Upper bound of the number of nodes left to explore at this level this
     * search
     */
    int[] upper;

    /** Number of nodes in the bag */
    public int size = 0;

    /** Counts the number of nodes explored during the tree exploration */
    protected int count = 0;

    /**
     * Returns a messageDigest instance that will create a seemingly random
     * output for some input.
     *
     * @return SHA-1 message digest if available, throws an exception if not
     *         available.
     */
    public static MessageDigest encoder() {
        try {
            return MessageDigest.getInstance("SHA-1");
        } catch (final NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Generates the next level of nodes from the current level (kept by member
     * size) and stores it in the arrays depth, lower and upper.
     *
     * @param md
     *            pseudo-random sequence generator
     * @param d
     *            depth limit of desired tree. If 0, will increase generated
     * @throws DigestException
     *             if there is an issue with the encoder
     */
    private void digest(MessageDigest md, int d) throws DigestException {
        // Creates more space in the arrays if need be
        if (size >= depth.length) {
            grow();
        }
        // processor.giveFold(new Sum(1));
        ++count; // We are exploring one node (expanding its child nodes)
        final int offset = size * 20;
        md.digest(hash, offset, 20); // Writes onto array hash on the next 20
        // cells or bytes.

        // What is the tree going to look like ?
        final int v = ((0x7f & hash[offset + 16]) << 24)
                | ((0xff & hash[offset + 17]) << 16)
                | ((0xff & hash[offset + 18]) << 8)
                | (0xff & hash[offset + 19]); // v is the positive integer made
                                              // of the 4
                                              // bytes in the hash array
                                              // generated by
                                              // the message digest 'digest'
                                              // previous
                                              // call
        final int n = (int) (Math.log(1.0 - v / 2147483648.0) / den);
        // 2.147.483.648 is written as 1 followed by 63 zeros in binary : -1.
        // v / 2.147.483.648 is then in the range (-2147483647,0]
        // n is then a positive integer, sometimes = 0, sometimes greater.
        if (n > 0) {
            if (d > 1) { // Bound for tree depth
                // We create node size
                depth[size] = d - 1;
                lower[size] = 0;
                upper[size] = n;
                size++;
            } else {
                // processor.giveFold(new Sum(n));
                count += n;
            }
        }
    }

    /**
     * Initializes the hash array with zeros from indices 0 to 15 and writes
     * number s (32 bit - 4 bytes integer) in the next 4 cells (from indices 16
     * to 19 included), updates the message digest to use the beginning of array
     * hash on these cells and calls the parser to generate the random hash
     *
     * @param md
     *            the message digest used to generate a 'random' sequence
     * @param seed
     *            the seed to generate the tree from
     * @param depth
     *            the depth bound of the tree to create
     */
    public void seed(MessageDigest md, int seed, int depth) {
        try {
            for (int i = 0; i < 16; ++i) {
                hash[i] = 0;
            }
            hash[16] = (byte) (seed >> 24);
            hash[17] = (byte) (seed >> 16);
            hash[18] = (byte) (seed >> 8);
            hash[19] = (byte) seed;
            md.update(hash, 0, 20);
            digest(md, depth);
        } catch (final DigestException e) {
        }
    }

    /**
     * Explores the current node, computing the arrays[size] cells. The main
     * point is to determine the number of child nodes of the current node
     *
     * @param md
     *            the hash digest
     * @throws DigestException
     *             possibly thrown by the {@link MessageDigest}
     */
    public void expand(MessageDigest md) throws DigestException {
        final int top = size - 1; // top is the previous node, top is then the
                                  // index
                                  // of the parent node in the arrays
        final int d = depth[top];
        final int l = lower[top];
        final int u = upper[top] - 1;
        if (u == l) {
            size = top; // We go back to the top node, we have explored all
                        // nodes on
                        // the top + 1 level
        } else {
            upper[top] = u; // We decrement the child nodes of top (the current
                            // node's
                            // parent node) : we have finished exploring all the
                            // child
                            // nodes of the current node
        }

        // Setting up a new 'seed' to explore the current node's child nodes
        final int offset = top * 20;
        hash[offset + 20] = (byte) (u >> 24);
        hash[offset + 21] = (byte) (u >> 16);
        hash[offset + 22] = (byte) (u >> 8);
        hash[offset + 23] = (byte) u;
        md.update(hash, offset, 24); // seed takes into account both the parent
                                     // seed
                                     // and 'u'
        digest(md, d);
    }

    /**
     * Explores the whole tree
     *
     * @param md
     *            the message digest used to generate the tree from the seed
     */
    public void run(MessageDigest md) {
        try {
            while (!isEmpty()) {
                expand(md);
            }
        } catch (final DigestException e) {
        }
    }

    /**
     * Creates a new UTS instance containing half of the nodes left to explore
     * from the current state of affairs
     *
     * @return a new UTS instance with half the known work of the current one
     */
    @Override
    public LegacyUTS split() {
        int s = 0;
        for (int i = 0; i < size; ++i) {
            if ((upper[i] - lower[i]) >= 2) {
                ++s;
            }
        }
        if (s == 0) {
            return null;
        }
        final LegacyUTS b = new LegacyUTS(s);
        for (int i = 0; i < size; ++i) {
            final int p = upper[i] - lower[i];
            if (p >= 2) {
                System.arraycopy(hash, i * 20, b.hash, b.size * 20, 20);
                b.depth[b.size] = depth[i];
                b.upper[b.size] = upper[i];
                b.lower[b.size++] = upper[i] -= p / 2;
            }
        }
        return b;
    }

    /**
     * Merges the given UTS's work into the current instance
     *
     * @param b
     *            the work to be done
     */
    @Override
    public void merge(LegacyUTS b) {
        final int s = size + b.size;
        while (s > depth.length) {
            grow();
        }
        System.arraycopy(b.hash, 0, hash, size * 20, b.size * 20);
        System.arraycopy(b.depth, 0, depth, size, b.size);
        System.arraycopy(b.lower, 0, lower, size, b.size);
        System.arraycopy(b.upper, 0, upper, size, b.size);
        size = s;
    }

    /**
     * Increases the size of array members hash, depth, lower and upper.
     */
    private void grow() {
        final int n = depth.length * 2;
        final byte[] h = new byte[n * 20 + 4];
        final int[] d = new int[n];
        final int[] l = new int[n];
        final int[] u = new int[n];
        System.arraycopy(hash, 0, h, 0, size * 20);
        System.arraycopy(depth, 0, d, 0, size);
        System.arraycopy(lower, 0, l, 0, size);
        System.arraycopy(upper, 0, u, 0, size);
        hash = h;
        depth = d;
        lower = l;
        upper = u;
    }

    /*
     * (non-Javadoc)
     *
     * @see apgas.glb.Bag#process(int)
     */
    @Override
    public void process(int workAmount) {
        final MessageDigest md = encoder();
        while (!isEmpty() && workAmount > 0) {
            try {
                expand(md);
            } catch (final DigestException e) {
                e.printStackTrace();
            }
            workAmount--;
        }

    }

    /*
     * (non-Javadoc)
     *
     * @see apgas.glb.Bag#submit(apgas.glb.Fold)
     */
    @Override
    public void submit(Sum r) {
        r.sum += count;
    }

    /*
     * (non-Javadoc)
     *
     * @see apgas.glb.Bag#isEmpty()
     */
    @Override
    public boolean isEmpty() {
        return size < 1;
    }

    /**
     * Static method used for formatting the performance output in the
     * {@link #main(String[])} method. Selects the substring situated between
     * the specified bounds and returns it. It case the 'end' bound is greater
     * than the actual length of the string, the end of the string will be used
     * instead.
     *
     * @param str
     *            the string from which a substring is to be taken
     * @param start
     *            start index of the substring to be returned
     * @param end
     *            end index of the substring to be returned
     * @return substring held between the specified indices
     */
    public static String sub(String str, int start, int end) {
        return str.substring(start, Math.min(end, str.length()));
    }

    /**
     * Constructor
     * <p>
     * Creates an empty UTS with no nodes to explore.
     */
    public LegacyUTS() {
    }

    /**
     * Constructor
     * <p>
     * Initialized an instance with room to accomodate a tree exploration of
     * specified depth.
     *
     * @param n
     *            depth of the exploration that will be possible to perform
     *            without increasing the size of the various arrays used in the
     *            implementation of the Unbalanced Tree Search.
     */
    public LegacyUTS(int n) {
        hash = new byte[n * 20 + 4]; // slack for in-place SHA1 computation :
                                     // n*20
                                     // as 20 cells are needed for each level
                                     // and 4
                                     // extra for last cell child seeds
        depth = new int[n];
        lower = new int[n];
        upper = new int[n];
    }

    /**
     * Launches the computation
     *
     * @param args
     *            one argument can be specified : the depth of the tree to
     *            explore. If no argument is given, the default value, 13 is
     *            used.
     */
    public static void main(String[] args) {
        String config = "";
        int depth;
        int workUnit;
        final GLBProcessor processor;
        try {
            depth = Integer.parseInt(args[0]);
            workUnit = Integer.parseInt(args[1]);
            if (Integer.parseInt(args[2]) == 0) {
                processor = GLBProcessorFactory.LoopGLBProcessor(workUnit, 1);
                config += "LoopGLBProcessor ";
            } else {
                processor = GLBProcessorFactory.GLBProcessor(workUnit, 1,
                        new HypercubeStrategy());
                config += "Hypercube GenericGLBProcessor ";
            }
            config += "UTS depth: " + depth + " Rdm Steals: " + 1
                    + " Work unit: " + workUnit;
        } catch (final Exception e) {
            System.err.println("Program requires three arguments :");
            System.err.println("\t tree depth");
            System.err.println("\t work unit value");
            System.err.println(
                    "\t GLB version: 0 for LoopGLBProcessor, 1 for GenericGLBProcessor with hypercube strategy");
            return;
        }

        final MessageDigest md = encoder();

        final LegacyUTS taskBag = new LegacyUTS(64);
        taskBag.seed(md, 19, depth - 2);

        System.out.print(config + ";");

        processor.compute(taskBag, new Sum(0));

        final LegacyUTS secondBag = new LegacyUTS(64);
        secondBag.seed(md, 19, depth);

        final long start = System.nanoTime();
        final long count = processor.compute(secondBag, new Sum(0)).sum;

        final long finish = System.nanoTime();

        final long computationTime = finish - start;

        System.out.print("Depth: " + depth + ", Performance: " + count
                + "nodes / " + sub("" + computationTime / 1e9, 0, 6)
                + "seconds = "
                + sub("" + (count / (computationTime / 1e3)), 0, 6)
                + "M nodes/s;"
                + sub("" + (count / (computationTime / 1e3)), 0, 6) + ";");
        System.out.println();

        final Logger[] logs = processor.getLogger();
        for (int i = 0; i < logs.length; i++) {
            System.err.println("Place " + i);
            logs[i].print(System.err);

        }

    }

}
